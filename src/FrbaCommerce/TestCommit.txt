Por ejemplo, la siguiente clase se declara como static y sólo contiene métodos static:
C#

    static class CompanyEmployee
    {
        public static void DoSomething() { /*...*/ }
        public static void DoSomethingElse() { /*...*/  }
    }



Una declaración de tipos o de constante constituye, implícitamente, un miembro estático.
No se puede hacer referencia a un miembro estático por medio de una instancia. En vez de ello, se debe hacer referencia por medio del nombre de tipo. Por ejemplo, considere la siguiente clase:
C#

    public class MyBaseC
    {
        public struct MyStruct
        {
            public static int x = 100;
        }
    }



Para referirse al miembro estático x, use el nombre completo, MyBaseC.MyStruct.x, a menos que el miembro sea accesible desde el mismo ámbito:
C#
Console.WriteLine(MyBaseC.MyStruct.x);
Mientras que una instancia de una clase contiene una copia independiente de todos los campos de instancia de la clase, sólo existe una copia de cada campo estático.
No es posible utilizar this para hacer referencia a descriptores de acceso de propiedades o métodos static.
Si la palabra clave static se aplica a una clase, todos los miembros de la clase deben ser estáticos.
Las clases y las clases estáticas pueden tener constructores estáticos. Se llama a los constructores estáticos en algún momento comprendido entre el inicio del programa y la creación de instancias de la clase.
NotaNota
El uso de la palabra clave static es más limitado que en C++. Para comparar con la palabra clave de C++, vea Static (C++).
Para comprender el uso de miembros estáticos, considere una clase que representa al empleado de una compañía. Suponga que la clase contiene un método que cuenta empleados y un campo que almacena el número de empleados. Ni el método ni el campo pertenecen a ninguna instancia de empleado. En vez de ello, pertenecen a la clase compañía. Por tanto, se deberían declarar como miembros estáticos de la clase.
Este ejemplo lee el nombre y el identificador de un nuevo empleado, incrementa en uno el contador de empleados y muestra la información del nuevo empleado y el nuevo número de empleados. Por motivos de simplicidad, el programa lee el número actual de empleados desde el teclado. En una aplicación real, esta información se leería desde un archivo.
C#

    public class Employee4
{
    public string id;
    public string name;

    public Employee4()
    {
    }

    public Employee4(string name, string id)
    {
        this.name = name;
        this.id = id;
    }

    public static int employeeCounter;

    public static int AddEmployee()
    {
        return ++employeeCounter;
    }
}

class MainClass : Employee4
{
    static void Main()
    {
        Console.Write("Enter the employee's name: ");
        string name = Console.ReadLine();
        Console.Write("Enter the employee's ID: ");
        string id = Console.ReadLine();

        // Create and configure the employee object:
        Employee4 e = new Employee4(name, id);
        Console.Write("Enter the current number of employees: ");
        string n = Console.ReadLine();
        Employee4.employeeCounter = Int32.Parse(n);
        Employee4.AddEmployee();

        // Display the new information:
        Console.WriteLine("Name: {0}", e.name);
        Console.WriteLine("ID:   {0}", e.id);
        Console.WriteLine("New Number of Employees: {0}",
                      Employee4.employeeCounter);
    }
}
    /*
    Input:
    Matthias Berndt
    AF643G
    15
     * 
    Sample Output:
    Enter the employee's name: Matthias Berndt
    Enter the employee's ID: AF643G
    Enter the current number of employees: 15
    Name: Matthias Berndt
    ID:   AF643G
    New Number of Employees: 16
    */



Este ejemplo muestra que, aunque se puede inicializar un campo estático utilizando otro campo estático aún sin declarar, el resultado no estará definido hasta que no asigne explícitamente un valor al campo estático.
C#

class Test
{
   static int x = y;
   static int y = 5;

   static void Main()
   {
      Console.WriteLine(Test.x);
      Console.WriteLine(Test.y);

      Test.x = 99;
      Console.WriteLine(Test.x);
   }
}
/*
Output:
    0
    5
    99
*/